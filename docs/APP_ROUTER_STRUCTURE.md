# Next.js App Router 디렉토리 구조 가이드

> 참고: [Next.js 공식 문서](https://context7.com/vercel/next.js/llms.txt)

## 목차

- [개요](#개요)
- [기본 디렉토리 구조](#기본-디렉토리-구조)
- [특수 파일(Special Files)](#특수-파일special-files)
- [라우팅 구조](#라우팅-구조)
- [권장 프로젝트 구조](#권장-프로젝트-구조)
- [실전 예시](#실전-예시)
- [베스트 프랙티스](#베스트-프랙티스)

---

## 개요

Next.js App Router는 **파일 시스템 기반 라우팅**을 사용합니다. `app` 디렉토리 내의 폴더 구조가 곧 URL 경로가 되며, 특수 파일들이 각 라우트의 UI와 동작을 정의합니다.

### 핵심 원칙

- 📁 **폴더** = 라우트 세그먼트 (URL 경로)
- 📄 **특수 파일** = UI 컴포넌트 및 동작 정의
- 🎯 **Convention over Configuration** = 파일 이름으로 기능 결정

---

## 기본 디렉토리 구조

```
app/
├── layout.tsx          # 루트 레이아웃 (필수)
├── page.tsx            # 홈페이지 (/)
├── loading.tsx         # 로딩 UI
├── error.tsx           # 에러 UI
├── not-found.tsx       # 404 페이지
├── globals.css         # 전역 스타일
│
├── about/              # /about 경로
│   ├── page.tsx
│   └── layout.tsx      # about 하위 레이아웃 (선택)
│
├── blog/               # /blog 경로
│   ├── page.tsx
│   ├── [slug]/         # 동적 라우트: /blog/:slug
│   │   ├── page.tsx
│   │   └── loading.tsx
│   └── [...slug]/      # Catch-all: /blog/*
│       └── page.tsx
│
└── api/                # API 라우트
    ├── users/
    │   └── route.ts    # GET/POST /api/users
    └── posts/
        └── [id]/
            └── route.ts # GET/PUT/DELETE /api/posts/:id
```

---

## 특수 파일(Special Files)

### 1. `layout.tsx` - 레이아웃

**목적**: 여러 페이지에서 공유되는 UI를 정의합니다. 레이아웃은 상태를 유지하며 리렌더링되지 않습니다.

**특징**:

- 루트 레이아웃(`app/layout.tsx`)은 **필수**
- 중첩 가능 (부모 레이아웃이 자식 레이아웃을 감쌈)
- `<html>`, `<body>` 태그는 루트 레이아웃에만 작성

```typescript
// app/layout.tsx (루트 레이아웃 - 필수)
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'My App',
  description: 'Generated by create next app',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ko">
      <body className={inter.className}>
        <header>공통 헤더</header>
        {children}
        <footer>공통 푸터</footer>
      </body>
    </html>
  );
}
```

```typescript
// app/dashboard/layout.tsx (중첩 레이아웃)
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="dashboard-container">
      <aside>사이드바</aside>
      <main>{children}</main>
    </div>
  );
}
```

---

### 2. `page.tsx` - 페이지

**목적**: 라우트의 실제 UI를 렌더링합니다. 폴더에 `page.tsx`가 있어야 해당 경로에 접근 가능합니다.

```typescript
// app/page.tsx → /
export default function HomePage() {
  return <h1>홈페이지</h1>;
}

// app/about/page.tsx → /about
export default function AboutPage() {
  return <h1>소개 페이지</h1>;
}

// app/blog/[slug]/page.tsx → /blog/:slug
type Props = {
  params: Promise<{ slug: string }>;
};

export default async function BlogPost({ params }: Props) {
  const { slug } = await params;
  return <h1>블로그 포스트: {slug}</h1>;
}
```

---

### 3. `loading.tsx` - 로딩 UI

**목적**: Suspense 경계를 자동으로 생성하여 로딩 상태를 표시합니다.

```typescript
// app/loading.tsx
export default function Loading() {
  return (
    <div className="loading-spinner">
      <p>로딩 중...</p>
    </div>
  );
}

// app/blog/loading.tsx (특정 경로에만 적용)
export default function BlogLoading() {
  return <div>블로그 로딩 중...</div>;
}
```

---

### 4. `error.tsx` - 에러 UI

**목적**: Error Boundary를 자동으로 생성하여 에러를 처리합니다.

**주의**: 반드시 `'use client'` 디렉티브 필요

```typescript
// app/error.tsx
'use client';

import { useEffect } from 'react';

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    console.error(error);
  }, [error]);

  return (
    <div>
      <h2>문제가 발생했습니다!</h2>
      <button onClick={() => reset()}>다시 시도</button>
    </div>
  );
}
```

---

### 5. `not-found.tsx` - 404 페이지

**목적**: 존재하지 않는 경로에 대한 UI를 표시합니다.

```typescript
// app/not-found.tsx
import Link from 'next/link';

export default function NotFound() {
  return (
    <div>
      <h1>404 - 페이지를 찾을 수 없습니다</h1>
      <Link href="/">홈으로 돌아가기</Link>
    </div>
  );
}
```

```typescript
// 특정 페이지에서 notFound() 트리거
import { notFound } from 'next/navigation';

export default async function Post({ params }: Props) {
  const { slug } = await params;
  const post = await getPost(slug);

  if (!post) {
    notFound(); // not-found.tsx를 렌더링
  }

  return <article>{post.content}</article>;
}
```

---

### 6. `route.ts` - API Route Handler

**목적**: REST API 엔드포인트를 생성합니다.

**지원 메서드**: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS

```typescript
// app/api/users/route.ts → /api/users
import {NextResponse} from 'next/server';

export async function GET() {
  const users = await fetchUsers();
  return NextResponse.json(users);
}

export async function POST(request: Request) {
  const body = await request.json();
  const newUser = await createUser(body);
  return NextResponse.json(newUser, {status: 201});
}
```

```typescript
// app/api/posts/[id]/route.ts → /api/posts/:id
import {NextRequest, NextResponse} from 'next/server';

type Params = {
  params: Promise<{id: string}>;
};

export async function GET(request: NextRequest, {params}: Params) {
  const {id} = await params;
  const post = await getPost(id);
  return NextResponse.json(post);
}

export async function DELETE(request: NextRequest, {params}: Params) {
  const {id} = await params;
  await deletePost(id);
  return NextResponse.json({success: true});
}
```

---

### 7. `template.tsx` - 템플릿

**목적**: `layout.tsx`와 유사하지만, 경로 변경 시마다 새 인스턴스가 생성됩니다.

**차이점**:

- `layout`: 상태 유지, 리렌더링 안 됨
- `template`: 매번 새로 마운트, 상태 초기화

```typescript
// app/template.tsx
export default function Template({ children }: { children: React.ReactNode }) {
  return <div className="page-transition">{children}</div>;
}
```

---

## 라우팅 구조

### 1. 정적 라우트

```
app/
├── about/page.tsx        # /about
├── contact/page.tsx      # /contact
└── blog/
    └── page.tsx          # /blog
```

---

### 2. 동적 라우트 (Dynamic Routes)

**`[폴더명]`**: 단일 동적 세그먼트

```typescript
// app/blog/[slug]/page.tsx → /blog/:slug
type Props = {
  params: Promise<{ slug: string }>;
};

export default async function BlogPost({ params }: Props) {
  const { slug } = await params;
  return <h1>{slug}</h1>;
}

// 정적 생성을 위한 generateStaticParams
export async function generateStaticParams() {
  const posts = await getPosts();
  return posts.map((post) => ({
    slug: post.slug,
  }));
}
```

---

### 3. Catch-all Routes

**`[...폴더명]`**: 모든 하위 경로를 캐치

```typescript
// app/docs/[...slug]/page.tsx
// → /docs/a, /docs/a/b, /docs/a/b/c 모두 매칭

type Props = {
  params: Promise<{ slug: string[] }>;
};

export default async function Docs({ params }: Props) {
  const { slug } = await params;
  // slug = ['a', 'b', 'c']
  return <h1>{slug.join(' / ')}</h1>;
}
```

**`[[...폴더명]]`**: Optional Catch-all (기본 경로도 포함)

```typescript
// app/shop/[[...category]]/page.tsx
// → /shop, /shop/electronics, /shop/electronics/phones 모두 매칭

type Props = {
  params: Promise<{ category?: string[] }>;
};

export default async function Shop({ params }: Props) {
  const { category } = await params;
  if (!category) {
    return <h1>모든 상품</h1>;
  }
  return <h1>카테고리: {category.join(' > ')}</h1>;
}
```

---

### 4. 병렬 라우트 (Parallel Routes)

**`@폴더명`**: 동시에 여러 페이지를 렌더링

```
app/
└── dashboard/
    ├── layout.tsx
    ├── @analytics/
    │   └── page.tsx
    ├── @team/
    │   └── page.tsx
    └── page.tsx
```

```typescript
// app/dashboard/layout.tsx
export default function DashboardLayout({
  children,
  analytics,
  team,
}: {
  children: React.ReactNode;
  analytics: React.ReactNode;
  team: React.ReactNode;
}) {
  return (
    <div>
      {children}
      <div className="grid">
        <div>{analytics}</div>
        <div>{team}</div>
      </div>
    </div>
  );
}
```

---

### 5. 인터셉팅 라우트 (Intercepting Routes)

**`(.)`**: 현재 레벨, **`(..)`**: 한 레벨 위, **`(..)(..)`**: 두 레벨 위

```
app/
├── photos/
│   ├── page.tsx
│   └── [id]/
│       └── page.tsx
└── @modal/
    └── (..)photos/
        └── [id]/
            └── page.tsx
```

---

### 6. 라우트 그룹 (Route Groups)

**`(폴더명)`**: URL에 영향을 주지 않는 그룹

```
app/
├── (marketing)/        # URL에 포함 안 됨
│   ├── about/
│   │   └── page.tsx    # /about
│   └── contact/
│       └── page.tsx    # /contact
│
└── (shop)/             # URL에 포함 안 됨
    ├── products/
    │   └── page.tsx    # /products
    └── cart/
        └── page.tsx    # /cart
```

**용도**:

- 레이아웃 그룹화 (다른 레이아웃 적용)
- 코드 조직화
- 다중 루트 레이아웃 생성

---

## 권장 프로젝트 구조

### 패턴 1: Feature-based Structure (기능별 구조)

```
app/
├── (auth)/                    # 인증 관련 라우트 그룹
│   ├── layout.tsx             # 인증 레이아웃 (로그인 페이지용)
│   ├── login/
│   │   └── page.tsx
│   └── register/
│       └── page.tsx
│
├── (main)/                    # 메인 애플리케이션 라우트 그룹
│   ├── layout.tsx             # 메인 레이아웃 (헤더, 푸터 포함)
│   ├── page.tsx               # 홈페이지
│   │
│   ├── blog/
│   │   ├── page.tsx           # 블로그 목록
│   │   ├── [slug]/
│   │   │   ├── page.tsx       # 블로그 상세
│   │   │   └── loading.tsx
│   │   └── _components/       # 블로그 전용 컴포넌트
│   │       ├── PostCard.tsx
│   │       └── PostList.tsx
│   │
│   └── portfolio/
│       ├── page.tsx
│       └── _components/
│           └── ProjectCard.tsx
│
└── api/
    ├── auth/
    │   └── [...nextauth]/
    │       └── route.ts
    ├── blog/
    │   └── route.ts
    └── portfolio/
        └── route.ts

src/
├── component/                 # 공통 컴포넌트
│   ├── ui/                    # UI 컴포넌트 (shadcn/ui)
│   │   ├── button.tsx
│   │   ├── card.tsx
│   │   └── input.tsx
│   │
│   ├── layout/                # 레이아웃 컴포넌트
│   │   ├── header.tsx
│   │   ├── footer.tsx
│   │   └── sidebar.tsx
│   │
│   └── common/                # 공통 기능 컴포넌트
│       └── providers/
│           ├── query-provider.tsx
│           └── theme-provider.tsx
│
├── lib/                       # 유틸리티 & 비즈니스 로직
│   ├── api/                   # API 클라이언트
│   │   ├── blog.ts
│   │   └── portfolio.ts
│   │
│   ├── hooks/                 # 커스텀 훅
│   │   ├── use-blog.ts
│   │   └── use-auth.ts
│   │
│   ├── types/                 # TypeScript 타입
│   │   ├── blog.ts
│   │   └── user.ts
│   │
│   ├── utils.ts               # 유틸리티 함수
│   └── constants.ts           # 상수
│
└── styles/                    # 전역 스타일
    └── globals.css
```

---

### 패턴 2: Simplified Structure (간소화된 구조)

소규모 프로젝트에 적합

```
app/
├── layout.tsx
├── page.tsx
├── about/
│   └── page.tsx
├── blog/
│   ├── page.tsx
│   └── [slug]/
│       └── page.tsx
└── api/
    └── posts/
        └── route.ts

src/
├── components/
│   ├── Header.tsx
│   ├── Footer.tsx
│   └── BlogPost.tsx
│
└── lib/
    ├── api.ts
    └── utils.ts
```

---

## 실전 예시

### 예시 1: 블로그 with Static Generation

```typescript
// app/blog/[slug]/page.tsx
import { notFound } from 'next/navigation';
import { getAllPosts, getPostBySlug } from '@/lib/api/blog';
import { Metadata } from 'next';

type Props = {
  params: Promise<{ slug: string }>;
};

// 메타데이터 생성
export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const { slug } = await params;
  const post = getPostBySlug(slug);

  if (!post) {
    return { title: 'Post Not Found' };
  }

  return {
    title: `${post.title} | My Blog`,
    description: post.excerpt,
    openGraph: {
      title: post.title,
      description: post.excerpt,
      images: [post.coverImage],
    },
  };
}

// 정적 경로 생성
export async function generateStaticParams() {
  const posts = getAllPosts();
  return posts.map((post) => ({
    slug: post.slug,
  }));
}

// 페이지 컴포넌트
export default async function BlogPost({ params }: Props) {
  const { slug } = await params;
  const post = getPostBySlug(slug);

  if (!post) {
    notFound();
  }

  return (
    <article>
      <h1>{post.title}</h1>
      <time>{post.date}</time>
      <div dangerouslySetInnerHTML={{ __html: post.content }} />
    </article>
  );
}
```

---

### 예시 2: API Route with Error Handling

```typescript
// app/api/posts/route.ts
import {NextRequest, NextResponse} from 'next/server';
import {z} from 'zod';

const postSchema = z.object({
  title: z.string().min(1),
  content: z.string().min(1),
});

export async function GET() {
  try {
    const posts = await fetchPosts();
    return NextResponse.json(posts);
  } catch (error) {
    return NextResponse.json({error: 'Failed to fetch posts'}, {status: 500});
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const validated = postSchema.parse(body);

    const newPost = await createPost(validated);
    return NextResponse.json(newPost, {status: 201});
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({error: 'Invalid request data', details: error.errors}, {status: 400});
    }
    return NextResponse.json({error: 'Failed to create post'}, {status: 500});
  }
}
```

---

### 예시 3: 국제화 (i18n) 구현

```
app/
└── [lang]/
    ├── layout.tsx
    ├── page.tsx
    └── about/
        └── page.tsx
```

```typescript
// i18n-config.ts
export const i18n = {
  defaultLocale: 'ko',
  locales: ['ko', 'en', 'ja'],
} as const;

export type Locale = (typeof i18n)['locales'][number];

// app/[lang]/layout.tsx
import { i18n, type Locale } from '@/i18n-config';

export async function generateStaticParams() {
  return i18n.locales.map((locale) => ({ lang: locale }));
}

export default async function RootLayout({
  children,
  params,
}: {
  children: React.ReactNode;
  params: Promise<{ lang: Locale }>;
}) {
  const { lang } = await params;

  return (
    <html lang={lang}>
      <body>{children}</body>
    </html>
  );
}

// app/[lang]/page.tsx
import { getDictionary } from '@/lib/dictionaries';

export default async function HomePage({
  params,
}: {
  params: Promise<{ lang: Locale }>;
}) {
  const { lang } = await params;
  const dict = await getDictionary(lang);

  return (
    <div>
      <h1>{dict.home.title}</h1>
      <p>{dict.home.description}</p>
    </div>
  );
}
```

---

## 베스트 프랙티스

### 1. 파일 네이밍 규칙

```
✅ 좋은 예:
- page.tsx
- layout.tsx
- loading.tsx
- error.tsx
- not-found.tsx
- route.ts

❌ 나쁜 예:
- Page.tsx (대문자 시작)
- page.js (TypeScript 사용 권장)
- index.tsx (App Router에서는 page.tsx 사용)
```

---

### 2. 컴포넌트 조직화

**규칙**: 라우트별 컴포넌트는 `_components` 폴더에 배치 (언더스코어는 라우트에서 제외됨)

```
app/
└── blog/
    ├── page.tsx
    ├── _components/          # 블로그 전용 컴포넌트 (라우트 아님)
    │   ├── PostCard.tsx
    │   ├── PostList.tsx
    │   └── PostFilter.tsx
    └── [slug]/
        └── page.tsx

src/component/                # 공통 컴포넌트
└── ui/
    ├── button.tsx
    └── card.tsx
```

---

### 3. Server Components vs Client Components

**기본 원칙**: 기본적으로 Server Component 사용, 필요할 때만 Client Component

```typescript
// ✅ Server Component (기본)
// - 데이터 fetching
// - 백엔드 리소스 접근
// - 민감한 정보 처리
export default async function BlogPost() {
  const posts = await fetchPosts(); // 서버에서 실행
  return <PostList posts={posts} />;
}

// ✅ Client Component
// - 인터랙션 (onClick, onChange)
// - State & Effects (useState, useEffect)
// - Browser API 사용
'use client';

import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

---

### 4. 데이터 Fetching 패턴

**패턴 1**: 페이지에서 직접 Fetch (Server Component)

```typescript
// app/posts/page.tsx
export default async function PostsPage() {
  const posts = await fetch('https://api.example.com/posts').then((r) =>
    r.json()
  );

  return <PostList posts={posts} />;
}
```

**패턴 2**: API Layer 분리 (권장)

```typescript
// lib/api/posts.ts
export async function getPosts() {
  const response = await fetch('https://api.example.com/posts', {
    cache: 'force-cache', // 캐싱 전략
  });
  return response.json();
}

// app/posts/page.tsx
import { getPosts } from '@/lib/api/posts';

export default async function PostsPage() {
  const posts = await getPosts();
  return <PostList posts={posts} />;
}
```

**패턴 3**: React Query 사용 (Client Component)

```typescript
// lib/hooks/use-posts.ts
'use client';

import { useQuery } from '@tanstack/react-query';
import { getPosts } from '@/lib/api/posts';

export function usePosts() {
  return useQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
  });
}

// app/posts/page.tsx
'use client';

import { usePosts } from '@/lib/hooks/use-posts';

export default function PostsPage() {
  const { data: posts, isLoading } = usePosts();

  if (isLoading) return <div>Loading...</div>;

  return <PostList posts={posts} />;
}
```

---

### 5. 레이아웃 재사용 전략

```typescript
// app/(main)/layout.tsx - 메인 레이아웃
export default function MainLayout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <Header />
      <main>{children}</main>
      <Footer />
    </>
  );
}

// app/(auth)/layout.tsx - 인증 레이아웃
export default function AuthLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="auth-container">
      <Logo />
      {children}
    </div>
  );
}
```

---

### 6. 캐싱 전략

```typescript
// 1. Force Cache (기본값) - 빌드 타임에 캐시
export default async function Page() {
  const data = await fetch('https://api.example.com/data', {
    cache: 'force-cache', // 정적 데이터
  });
}

// 2. No Store - 매 요청마다 새로 fetch
export default async function Page() {
  const data = await fetch('https://api.example.com/data', {
    cache: 'no-store', // 동적 데이터
  });
}

// 3. Revalidate - 특정 시간마다 재검증
export default async function Page() {
  const data = await fetch('https://api.example.com/data', {
    next: {revalidate: 3600}, // 1시간마다 재검증 (ISR)
  });
}

// 4. Tag-based Revalidation - 온디맨드 재검증
export default async function Page() {
  const data = await fetch('https://api.example.com/data', {
    next: {tags: ['posts']},
  });
}

// API Route에서 재검증 트리거
import {revalidateTag} from 'next/cache';

export async function POST() {
  revalidateTag('posts');
  return Response.json({revalidated: true});
}
```

---

### 7. 환경 변수 사용

```typescript
// .env.local
DATABASE_URL=postgresql://...
NEXT_PUBLIC_API_URL=https://api.example.com

// Server Component - 모든 환경 변수 접근 가능
export default async function Page() {
  const dbUrl = process.env.DATABASE_URL; // ✅ OK
}

// Client Component - NEXT_PUBLIC_ 접두사만 가능
'use client';

export default function Page() {
  const apiUrl = process.env.NEXT_PUBLIC_API_URL; // ✅ OK
  const dbUrl = process.env.DATABASE_URL; // ❌ undefined
}
```

---

## SOLID 원칙 적용

### 1. Single Responsibility Principle (SRP)

```typescript
// ❌ 나쁜 예: 여러 책임을 가진 페이지
export default async function PostsPage() {
  // 데이터 fetching
  const posts = await fetch('...').then((r) => r.json());

  // 데이터 변환
  const formattedPosts = posts.map(/* ... */);

  // UI 렌더링
  return <div>{/* 복잡한 UI */}</div>;
}

// ✅ 좋은 예: 책임 분리
// lib/api/posts.ts - 데이터 fetching
export async function getPosts() {
  return fetch('...').then((r) => r.json());
}

// lib/utils/post.ts - 데이터 변환
export function formatPosts(posts: Post[]) {
  return posts.map(/* ... */);
}

// app/posts/_components/PostList.tsx - UI 렌더링
export function PostList({ posts }: { posts: Post[] }) {
  return <div>{/* UI */}</div>;
}

// app/posts/page.tsx - 조합
import { getPosts } from '@/lib/api/posts';
import { formatPosts } from '@/lib/utils/post';
import { PostList } from './_components/PostList';

export default async function PostsPage() {
  const posts = await getPosts();
  const formatted = formatPosts(posts);
  return <PostList posts={formatted} />;
}
```

---

### 2. Dependency Inversion Principle (DIP)

```typescript
// ✅ 추상화에 의존
// lib/api/interface.ts
export interface PostRepository {
  getPosts(): Promise<Post[]>;
  getPost(id: string): Promise<Post>;
}

// lib/api/post-repository.ts
export class ApiPostRepository implements PostRepository {
  async getPosts() {
    return fetch('/api/posts').then((r) => r.json());
  }

  async getPost(id: string) {
    return fetch(`/api/posts/${id}`).then((r) => r.json());
  }
}

// lib/hooks/use-posts.ts
export function usePosts(repository: PostRepository) {
  return useQuery({
    queryKey: ['posts'],
    queryFn: () => repository.getPosts(),
  });
}
```

---

## 참고 자료

- [Next.js 공식 문서 - App Router](https://nextjs.org/docs/app)
- [Next.js 공식 문서 - Routing](https://nextjs.org/docs/app/building-your-application/routing)
- [Next.js Context7 Documentation](https://context7.com/vercel/next.js/llms.txt)

---

**작성일**: 2025-10-25
**버전**: Next.js 14/15/16
